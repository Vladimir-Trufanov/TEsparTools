## [TQueMessage - обеспечить передачу и приём сообщений через очередь в задачах и из прерываний](#) v3.2.8, 26.12.2024 

Класс ***TQueMessage*** предназначен для организации единообразной передачи сообщений в последовательный порт или на другую периферию. 

В классе определены 5 типов сообщений:

```
#define tmt_NOTICE  "NOTICE"     // информационное сообщение приложения 
#define tmt_TRACE   "TRACE"      // трассировочное сообщение при отладке
#define tmt_WARNING "WARNING"    // предупреждение, позволяющие работать задаче дальше 
#define tmt_ERROR   "ERROR"      // ошибка, не дающие возможность правильно выполнить задачу
#define tmt_FATAL   "FATAL"      // ошибка, вызывающие перезагрузку контроллера
``` 

Существуют три формата вывода сообщений в приложениях: краткий, полный, без даты и времени.

```
typedef enum {
   tfm_BRIEF,   // 0 Краткий             - WARNING-ISR[2]
   tfm_NOTIME,  // 1 Без даты и времени  - WARNING-ISR[2] Управление передаётся планировщику
   tfm_FULL,    // 2 Полный              - 2024-11-29,19:36:18 WARNING-ISR[2] Управление передаётся планировщику
} tFMess;
```

В полном сообщении указывается дата и время извлечения сообщения из очереди, тип сообщения, источник сообщения, номер сообщения источника, текст сообщения.

> Источник сообщения - это псевдоним приложения (модуля, библиотеки, любого объекта выполнения кода), которое отправляет сообщение.  Источник сообщения **tmk_APP** определяется автором продукта через директиву **#define**, не более 7 символов. 

В примере ***QueueHandlMulti.ino*** к классу ***TQueMessage***   источнику сообщения присваивается псевдоним ***"QHM"***:

```
// Определяем источник сообщений  
#define tmk_APP  "QHM"  // пример по обработке очередей
```

Некоторые примеры полных сообщений:
```
2024-11-29,19:36:18 WARNING-ISR[2]    Управление передаётся планировщику   
2024-11-29,19:38:45 ERROR-EUE[0]      Очередь не была создана и не может использоваться  
2024-11-30,08:11:54 NOTICE-KVIZZY[2]  Передано 124 сообщение из задачи  
```
---

### [Внешняя функция пeредачи сообщения на периферию](#%D0%B2%D0%BD%D0%B5%D1%88%D0%BD%D1%8F%D1%8F-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F-%D0%BF%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B8-%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BD%D0%B0-%D0%BF%D0%B5%D1%80%D0%B8%D1%84%D0%B5%D1%80%D0%B8%D1%8E)

### [Порядок фoрмирования списка сообщений приложения](#%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D0%BA-%D1%84%D0%BE%D1%80%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B0-%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D0%B9-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F)

### [Мeтоды класса TQueMessage](#%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%8B-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0-tquemessage)

---

### Внешняя функция передачи сообщения на периферию

Направление передачи информации определяется во внешней функции ***transmess***, которая может быть изменена пользователем. 

Функции передаются указатели на два массива символов с завершающим нулём: ***mess*** - собственно сообщение, которое проходит через очередь, и ***prefix*** - префикс сообщения (по умолчанию отсутствует).

Префикс сообщения, это краткий фрагмент текста, который выводится перед сообщением. Назначение или смысл префикса определяются разработчиком приложения.

```
// Передатчик сообщения на периферию с возможным префиксом:
// static char str[] = "Hello: ";
// queMessa.Post(queMessa.Receive(MessFormat),str);

inline void transmess(char *mess, char *prefix="") 
{
   // Выводим массивы символов с 0-вым окончанием
   Serial.print(prefix);  // передали префикс (по умолчанию отсутствует)
   Serial.println(mess);  // передали сообщение
}
```
### Порядок формирования списка сообщений приложения

Для того, чтобы использовать класс TQueMessage для передачи сообщений в приложении, все сообщения необходимо объявить через перечисление (где каждому сообщению ставится в соответствие его номер) и подготовить массив сообщений для заполнения буфера вывода на периферию.

Как образец,  далее приведено описание сообщений в примере по обработке очередей: 

```
// Определяем источник сообщений  
#define tmk_APP "QHM"   // пример по обработке очередей

// Определяем перечисления примера обработки очередей 
typedef enum {
   SendFromISR,          // 0 
   SendFromTask,         // 1 
   StructNoSend,         // 2 
   TaskNoQueue,          // 3
   SendLongMess,         // 4 maxi=255+0
}; 

// Формируем список сообщений приложения
tmessAPP amessAPP[] = 
{
    {SendFromISR,  tvm_1intmes, "Передано %s сообщение из прерывания"},
    {SendFromTask, tvm_2intmes, "Передано %s сообщение из задачи на %s миллисекунде"},
    {StructNoSend, tvm_1intmes, "Не удалось отправить структуру после %d тиков"},
    {TaskNoQueue,  tvm_simpmes, "Очереди структур нет в задаче"},
    {SendLongMess, tvm_simpmes, "Максимально длинное сообщение из 255 байт [буфер текстов сообщений максимально может содержать 255 байт и завершающий ноль 1234567890 1234567890 1234567890]"},
};

// Вычисляем размер списка
int SizeMess=sizeof(amessAPP)/sizeof(tmessAPP);
```

Приложения могут формировать сообщения трёх видов:

```
// Перечисление видов сообщений
enum {
   tvm_simpmes,   // 0 простое сообщение, без уточнений
   tvm_1intmes,   // 1 сообщение c одним уточнением целого типа
   tvm_2intmes,   // 2 сообщение c двумя уточнениями целого типа
};

``` 
Для запуска передачи сообщений в приложении через очередь нужно выполнить следующие действия:

- сформировать файл с массивом сообщений и подключить к приложению;
- подключить библиотеку QueMessage.h;
- при необходимости сделать свой передатчик сообщений вместо установленного в классе передатчика по умолчанию "transmess";
- построить объект работы с сообщениями через очередь TQueMessage с параметрами в соответствии со следующим форматом
```
TQueMessage(tmessAPP *aimessAPP, int iSizeMess, String itmk_APP="APP", int iQueueSize=4);

// *aimessAPP - указатель на массив сообщений приложения;
// iSizeMess  - размер массива сообщений;
// itmk_APP   - источник сообщения (по умолчанию "APP");
// iQueueSize - количество элементов очереди (по умолчанию 4)

``` 

- создать очередь (в функции Setup)
```
String inMess=queMessa.Create();   
```                                                 
- подключить функцию передачи сообщения на периферию 
```
queMessa.attachFunction(transmess2);
```
###### [к содержанию](#%D0%B2%D0%BD%D0%B5%D1%88%D0%BD%D1%8F%D1%8F-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F-%D0%BFe%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B8-%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BD%D0%B0-%D0%BF%D0%B5%D1%80%D0%B8%D1%84%D0%B5%D1%80%D0%B8%D1%8E)

### Методы класса TQueMessage

- ***Построить объект (конструктор класса)***. 

При определении в приложении переменной для объекта класса (то есть при вызове конструктора класса) можно указать максимальное количество сообщений, которое может быть помещено в очередь, по умолчанию 4 сообщения.

Формат:

```
TQueMessage(tmessAPP *aimessAPP, int iSizeMess, String itmk_APP="APP", int iQueueSize=4);

// *aimessAPP - указатель на массив сообщений приложения;
// iSizeMess  - размер массива сообщений;
// itmk_APP   - источник сообщения (по умолчанию "APP");
// iQueueSize - количество элементов очереди (по умолчанию 4)
```

- ***Создать очередь***

При вызове данного метода резервируется пространство в оперативной памяти для размещения сообщений очереди.

Формат:
```
String Create();
```
Если функции не удалось создать очередь, то она вернет строку ***tQueueNotCreate*** =  "***Очередь не была создана и не может использоваться***". Если все хорошо, то возвращается ***isOk***.

- ***Отправить просто сообщение, без уточнений*** (1 группа сообщений) 

```
String    Send(String Type,int Number,String Source=isOk); 
String SendISR(String Type,int Number,String Source=isOk);

// Type   - тип сообщения (например, tmt_WARNING);
// Number - номер сообщения из перечисления;
// Source - источник сообщения (по умолчанию isOk)
```
Через параметр ***Source*** можно изменить установленный источник сообщения.

-  ***Отправить сообщение с одним уточнением целого типа***

Указанным методом выполняется отправка сообщения в очередь с использованием дополнительного целочисленного параметра (***fmess32***). Здесь используются два варианта: ***Send*** - для выделенных задач в скетче, основного цикла и блока настройки setup; ***SendISR*** - для отправки сообщения из прерывания.

```
String    Send(String Type,int Number,int fmess32,String Source=isOk); 
String SendISR(String Type,int Number,int fmess32,String Source=isOk); 
```

-  ***Отправить сообщение с двумя уточнениями целого типа***

Здесь, через первый и второй параметр ***fmess32***, ***smess32*** передаются целочисленные значения, которые вставляются в указанные места (в массиве сообщений приложения).

Все методы отправки сообщений возвращают ***isOk*** в случае успешной отправки, иначе возвращают причину ошибки.

```
String Send(String Type,int Number,int fmess32,int smess32,String Source=isOk);

```

- ***Подключить внешнюю функцию передачи сообщения на периферию***

```
void attachFunction(void (*function)(char *mess, char *prefix));
```

- ***Выбрать сообщение из очереди***

Если к моменту выборки сообщения из очереди, очередь не пуста и в ней находятся несколько сообщений, то выбирается из очереди и комплектуется в соответствии с заданным форматом ***одно сообщение***.

Если выбрать элемент из очереди без ошибки не удалось, то возвращается сообщение вне формата ***ErrorReceiving*** = "***Ошибка при приёме сообщения из очереди***".

При выборке из очереди может еще быть получено несколько сообщений вне формата:

если очередь не создана, то методом возвращается сообщение ***NoQueueReceive*** = "***Прием сообщения: очередь структур не создана***". Если в очереди нет сообщений, то возвращается сообщение ***QueueEmptyReceive***  = "***Очередь пуста при приёме сообщения***". 

Все сообщения возвращаются методом, как массив до 255 символов с завершающим нулём.

Формат:
```
char* Receive(int t_MessFormat=tfm_FULL);
```
- ***Выбрать сообщение из очереди и отправить на периферию***

Существуют два метода, которые выбирают сообщения из очереди и сразу используют внешнюю функцию для отправки сообщения на периферию. Метод ***Post*** выбирает одно сообщение, а метод ***PostAll*** выбирает сразу все сообщения, которые к моменту накопились в очереди.
```
// Выбрать сообщение из очереди и отправить на периферию 
char* Post(int t_MessFormat=tfm_FULL,char *prefix="");

// Выбрать все сообщения разом из очереди и отправить на периферию
void PostAll(int t_MessFormat=tfm_FULL,char *prefix="");
```
- ***Определить количество свободных мест в очереди***
```
int How_many_free();
```
- ***Определить, сколько сообщений накопилось в очереди и их можно выгрузить***
```
int How_many_wait(); 
```
###### [к содержанию](#%D0%B2%D0%BD%D0%B5%D1%88%D0%BD%D1%8F%D1%8F-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F-%D0%BFe%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B8-%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BD%D0%B0-%D0%BF%D0%B5%D1%80%D0%B8%D1%84%D0%B5%D1%80%D0%B8%D1%8E)
